/*
 * 区间的模糊排序
 * 思路和快排是一样的，也是采用分治策略
 * 1. 分解：把区间数组分解为三部分，第一部分大于主元区间，第二部分等于主元区间，第三部分大于主元区间
 * 2. 解决：通过递归调用，对第一和第三部分排序
 * 3. 因为是原址排序，不需要合并
 * 
 * 重点1
 * 
 * 当两个区间有重叠部分时，则两个区间相等
 * 区间使用长度为2的数组定义
 * 
 * 重点2
 * 主元会在比较过程中不断调整大小，当和被比较元素相等时会调整为主元和被比较元素的交集，这一点非常重要。
 * 比如要排序：[1,3],[4,6],[2,9]
 * 当主元为[2,9]是，它和[1,3]比较后，主元需调整为交集[2,3],这样才能保证[4,6]排在[1,3]的后面
 * 
 * 重点3
 * 由于区间模糊排序将元素分为了3部分，所以计算分割位置时，需返回两个值，分别指向最小部分和相等部分的交界及相等部分和最大部分的交界。
 * */

function intervalFuzzySort(A,p,r){
	if(p<r){
		q=fuzzyPartion(A,p,r);
		intervalFuzzySort(A,p,q[0]-1);
		intervalFuzzySort(A,q[1]+1,r);
	}
}

function fuzzyPartion(A,p,r){
	let x=A[r];
	let m=[...x];//主元会在比较过程中不断调整大小，当相等时会调整为主元和被比较元素的交集，这一点非常重要，比如[2,3],[4,6],[2,9]
	let i=p-1;//记录和主元相等部分的第一个位置
	let j=p-1;//记录和主元相等部分的最后一个位置
	
	for(k=p;k<r;k++){
		if(A[k][1]<=m[0]){
			i++;
			j++;
			[A[k],A[i]]=[A[i],A[k]];
		}else if(A[k][0]>=m[1]){
			continue;
		}else{
			j++;
			m=crossInterval(m,A[k]);
			[A[k],A[j]]=[A[j],A[k]];
		}
	}
	i++;
	j++;
	[A[j],A[r]]=[A[r],A[j]];
	return [i,j];
}

function crossInterval(a,b){
	let start=Math.max(a[0],b[0]);
	let end=Math.min(a[1],b[1]);
	if(start<end){
		return [start,end];
	}
	return null;
}

/*测试-----*/

let A=[[2,9],[5,7],[8,9],[2,5],[3,4],[4,6],[9,10],[6,8],[1,3]];
intervalFuzzySort(A,0,A.length-1);
console.log(A);

/*
 *性能：当区间重叠越来越多的时候，区间的模糊排序问题会变得越来越容易，因为重叠的部分越多剩余需要递归排序的部分就越少 
 * */


